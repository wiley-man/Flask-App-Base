# Flask Application Base

**Here’s a clean, battle-tested way to configure a Flask app for development, testing, and production using the app-factory pattern, config classes, and environment variables.**

## 1) Project layout

```text
flask-app-base/
├─ flaskapp/
|  ├─ templates/
|  |  └─ index.html      # jinja2 template for home page
│  ├─ __init__.py        # app factory lives here
│  ├─ extensions.py      # db, migrate instances
│  ├─ routes.py
│  ├─ models.py
│  └─ config.py          # all configs in one place
├─ instance/             # machine-specific, not committed
|  ├─ dev.db             # lives here when using SQLite (generated by alembic)
│  └─ config.py          # optional local secrets/overrides
├─ migrate/              # flask migration (generated by alembic)
├─ .env                  # dev-only env vars (never in prod)
├─ .env.test             # test-only env vars
├─ wsgi.py               # for prod servers (gunicorn/uwsgi)
└─ tests/
├─ conftest.py
├─ test_home.py
└─ test_example.py
```

## 2) Config classes (flaskapp/config.py)

```python
import os
from datetime import timedelta

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DEFAULT_DB = f"sqlite:///{os.path.join(BASE_DIR, '..', 'app.db')}"

class Config:
    SECRET_KEY = os.environ.get("SECRET_KEY", "dev-insecure")  # override in prod!
    SQLALCHEMY_DATABASE_URI = os.environ.get("DATABASE_URL", DEFAULT_DB)
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SESSION_COOKIE_HTTPONLY = True
    REMEMBER_COOKIE_HTTPONLY = True
    PERMANENT_SESSION_LIFETIME = timedelta(days=7)
    # Logging level (can be overridden)
    LOG_LEVEL = os.environ.get("LOG_LEVEL", "INFO")

class DevelopmentConfig(Config):
    DEBUG = True
    # Helpful for dev: show Werkzeug debugger, etc.
    # Use a separate dev DB if you like
    SQLALCHEMY_DATABASE_URI = os.environ.get("DEV_DATABASE_URL", DEFAULT_DB)

class TestingConfig(Config):
    TESTING = True
    DEBUG = True
    # In-memory DB by default for isolation/speed
    SQLALCHEMY_DATABASE_URI = os.environ.get("TEST_DATABASE_URL", "sqlite:///:memory:")
    WTF_CSRF_ENABLED = False  # usually disabled for tests
    # Make cookies non-secure to avoid HTTPS requirement in tests
    SESSION_COOKIE_SECURE = False

class ProductionConfig(Config):
    DEBUG = False
    # Production must provide strong secrets + real DB
    SECRET_KEY = os.environ["SECRET_KEY"]      # crash early if missing
    SQLALCHEMY_DATABASE_URI = os.environ["DATABASE_URL"]
    SESSION_COOKIE_SECURE = True
    REMEMBER_COOKIE_SECURE = True
    # Example: stricter headers
    # SEND_FILE_MAX_AGE_DEFAULT = 31536000
```

## 3) App factory (flaskapp/__init__.py)

```python
import logging
import os
from flask import Flask
from .config import DevelopmentConfig, TestingConfig, ProductionConfig
from .routes import routes_bp # assume you have a blueprint
from .extensions import db, migrate
from .models import Quote

CONFIG_MAP = {
    "development": DevelopmentConfig,
    "testing": TestingConfig,
    "production": ProductionConfig,
}

def create_app(config_name: str | None = None) -> Flask:
    # Allow env var to choose config (default: development)
    config_name = config_name or os.getenv("FLASK_ENV_NAME", "development")

    app = Flask(__name__, instance_relative_config=True)
    os.makedirs(app.instance_path, exist_ok=True)

    # Base config from class
    app.config.from_object(CONFIG_MAP[config_name])

    # Optional: load instance/ config (ignored if missing)
    app.config.from_pyfile("config.py", silent=True)

    # Optional: allow an env var to point to a file with secrets
    # e.g., export YOURAPP_SETTINGS=/path/to/production.cfg
    app.config.from_envvar("YOURAPP_SETTINGS", silent=True)

    # ---- Extensions ----
    db.init_app(app)
    migrate.init_app(app, db)

    # Blueprints, extensions, CLI, etc.
    app.register_blueprint(routes_bp)

    _configure_logging(app)

    # ---- CLI: seed data ----
    @app.cli.command("seed-quotes")
    def seed_quotes():
        """Insert a few sample quotes (idempotent-ish)."""
        samples = [
            Quote(text="Simplicity is the soul of efficiency.", author="Austin Freeman"),
            Quote(text="Programs must be written for people to read.", author="Harold Abelson"),
            Quote(text="Talk is cheap. Show me the code.", author="Linus Torvalds"),
        ]
        # Only add if table is empty
        if Quote.query.count() == 0:
            db.session.add_all(samples)
            db.session.commit()
            print("Seeded sample quotes.")
        else:
            print("Quotes already present; skipping seed.")

    return app

def _configure_logging(app: Flask) -> None:
    # Simple per-environment logging
    level = getattr(logging, app.config.get("LOG_LEVEL", "INFO").upper(), logging.INFO)
    handler = logging.StreamHandler()
    handler.setLevel(level)
    fmt = "[%(asctime)s] %(levelname)s in %(module)s: %(message)s"
    handler.setFormatter(logging.Formatter(fmt))
    app.logger.setLevel(level)
    if not any(isinstance(h, logging.StreamHandler) for h in app.logger.handlers):
        app.logger.addHandler(handler)
```

Why FLASK_ENV_NAME?

Flask 3.x removed FLASK_ENV. You control debug mode with FLASK_DEBUG=1, and you choose your config class yourself (here via 

FLASK_ENV_NAME=development|testing|production).

## 4) Environment selection

### Development (local)

.env (auto-loaded by flask run via python-dotenv):

```ini
FLASK_APP=wsgi.py
FLASK_DEBUG=1
FLASK_ENV_NAME=development
DEV_DATABASE_URL=sqlite:///dev.db
SECRET_KEY=dev-only
```

Run:

```bash
flask run
```

or

```bash
python -m flask run
```

### Production

Set real environment variables at deploy time (no .env files):

```ini
export FLASK_ENV_NAME=production
export SECRET_KEY='super-long-random-string'
export DATABASE_URL='postgresql+psycopg://user:pass@host/db'
export LOG_LEVEL=INFO
```

WSGI entry (wsgi.py):

```python
from yourapp import create_app
app = create_app()  # picks up FLASK_ENV_NAME
```

Example gunicorn command:

```bash
gunicorn "wsgi:app" --bind 0.0.0.0:8000 --workers 3
```

## 5) Instance config (optional)

Anything in instance/config.py is ignored by git and loads after your class config—great for per-host overrides:

\# instance/config.py

```ini
SECRET_KEY = "dev-machine-secret"
```

## 6) Adding SQLAlchemy and migrate to flask

- uses Flask-SQLAlchemy for models
- wires up Flask-Migrate for schema changes
- replaces the raw sqlite3 calls with ORM queries
- keeps your blueprint home route that shows a random “Comment of the Day”

## 7) flaskapp/extensions.py

```python
# flaskapp/extensions.py
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

db = SQLAlchemy()
migrate = Migrate()
```

## 8) flaskapp/models.py

```python
# flaskapp/models.py
from .extensions import db

class Quote(db.Model):
    __tablename__ = "quotes"

    id = db.Column(db.Integer, primary_key=True)
    text = db.Column(db.Text, nullable=False)
    author = db.Column(db.String(255))

```

## 9) flaskapp/routes.py

```python
# flaskapp/routes.py
from flask import Blueprint, render_template
from sqlalchemy import func
from .models import Quote

routes_bp = Blueprint("routes", __name__)

@routes_bp.route("/")
def home():
    row = Quote.query.order_by(func.random()).first()
    if row is None:
        quote, author = "No quotes yet. Run: flask db upgrade && flask seed-quotes", None
    else:
        quote, author = row.text, (row.author or None)
    return render_template("index.html", quote=quote, author=author)
```

Note: func.random() works on SQLite & Postgres.

On MySQL/MariaDB, Alembic/SQLAlchemy will translate to RAND() automatically.

## 10) flaskapp/templates/index.html

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Home</title>
    <style>
      body { font-family: system-ui, Arial, sans-serif; margin: 2rem; }
      .quote { font-size: 1.25rem; line-height: 1.6; }
      .author { margin-top: .5rem; opacity: .7; }
    </style>
  </head>
  <body>
    <h1>Comment of the Day</h1>
    <p class="quote">“{{ quote }}”</p>
    {% if author %}
      <p class="author">— {{ author }}</p>
    {% endif %}
  </body>
</html>
```

## 11) Initialize Flask-Migrate & create the migration

From your project root (where FLASK_APP=yourapp resolves to this package):

```bash
# one-time: set env vars for local dev
export FLASK_APP=yourapp
export FLASK_DEBUG=1

# 1) initialize Alembic (creates migrations/ folder)
flask db init

# 2) generate initial migration from models.py
flask db migrate -m "create quotes table"

# 3) apply it to the configured DB
flask db upgrade

# 4) optional: seed some data
flask seed-quotes
```

## 12) Testing (pytest)

.env.test (loaded in tests if you call dotenv.load_dotenv('.env.test')):

```ini
FLASK_ENV_NAME=testing
TEST_DATABASE_URL=sqlite:///:memory:
```

tests/conftest.py:

```python
# tests/conftest.py (snippet)
import os
import pytest
from flaskapp import create_app
from dotenv import load_dotenv
from flaskapp import create_app
from flaskapp.extensions import db
from flaskapp.models import Quote

@pytest.fixture(scope="session")
def app():
  load_dotenv(".env.test")
  app = create_app("testing")
  with app.app_context():
    db.create_all()
    db.session.add(Quote(text="Test quote", author="Tester"))
    db.session.commit()
    yield app
    db.drop_all()

@pytest.fixture()
def client(app):
  return app.test_client()
```

tests/test_home.py

```python
# tests/test_home.py
import pytest
from flask import template_rendered
from dotenv import load_dotenv
from flaskapp import db, Quote


# If your package is named `yourapp` and exposes create_app in __init__.py:
from flaskapp import create_app
from tests.conftest import captured_templates

# overload the app fixture to pre-populate the database
@pytest.fixture(scope="session")
def app():
  load_dotenv(".env.test")
  app = create_app("testing")
  with app.app_context():
    db.create_all()
    db.session.add(Quote(text="Test quote", author="Tester"))
    db.session.commit()
    yield app
    db.session.remove()
    db.drop_all()


def test_home_status_and_content(client):
    """GET / returns 200 and expected content from the homepage template."""
    resp = client.get("/")
    assert resp.status_code == 200
    # Adjust the expected bytes below if your template text differs.
    assert b"Test quote" in resp.data


def test_home_uses_index_template(app, client):
    """The home view renders index.html."""
    with captured_templates(app) as templates:
        _ = client.get("/")
        assert len(templates) == 1
        template, context = templates[0]
        assert template.name == "index.html"


def test_home_route_is_registered(app):
    """The blueprint is mounted at root with '/' -> endpoint 'routes.home'."""
    # The endpoint name is <blueprint_name>.<view_func_name>
    endpoints = {(r.rule, r.endpoint) for r in app.url_map.iter_rules()}
    assert ("/", "routes.home") in endpoints
```

tests/test_db.py

```python
# tests/test_db.py
from flaskapp import Quote, db
import pytest

def test_db_is_empty(session):
    """Database starts empty."""
    count = session.query(Quote).count()
    assert count == 0

def test_add_quote(session):
    """Can insert a quote into the database."""
    q = Quote(text="Testing is essential.", author="QA Bot")
    session.add(q)
    session.commit()

    stored = Quote.query.first()
    assert stored is not None
    assert stored.text == "Testing is essential."
    assert stored.author == "QA Bot"

def test_multiple_quotes_and_random(session):
    """Can store multiple quotes and select randomly."""
    quotes = [
        Quote(text="One", author="A"),
        Quote(text="Two", author="B"),
        Quote(text="Three", author="C"),
    ]
    session.add_all(quotes)
    session.commit()

    all_quotes = Quote.query.all()
    assert len(all_quotes) == 4  # 1 from test_add_quote + 3 new

    # Using SQLAlchemy func.random() to simulate random selection
    from sqlalchemy import func
    random_quote = Quote.query.order_by(func.random()).first()
    assert isinstance(random_quote, Quote)
    assert random_quote.text in {q.text for q in all_quotes}
```

## 13) Common gotchas & tips

- **Secrets:** never commit real SECRET_KEY or credentials. In prod, force them via os.environ["..."] to fail fast if missing.

- **Debug vs. Config:** FLASK_DEBUG=1 toggles debugger/reloader; it does not choose your database or other settings—your config class does.

- **Testing DB:** use sqlite:///:memory: or a throwaway Postgres DB per test session; create/drop schema in fixtures as needed.

- **Overrides order (later wins):**

1. Config class
2. instance/config.py
3. YOURAPP_SETTINGS file
4. app.config.from_mapping(...) if you add it

- **Logging:** tune per env (e.g., JSON logs in prod, DEBUG in dev).

- **Extensions:** initialize inside create_app so they respect the chosen config.
